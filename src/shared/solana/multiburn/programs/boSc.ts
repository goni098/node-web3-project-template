/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Address,
	containsBytes,
	fixEncoderSize,
	getBytesEncoder,
	type ReadonlyUint8Array
} from "@solana/kit"
import type {
	ParsedAcceptOwnershipInstruction,
	ParsedFundPoolInstruction,
	ParsedInitializeInstruction,
	ParsedInitializeMarketInstruction,
	ParsedInitializePoolInstruction,
	ParsedInitializeVaultInstruction,
	ParsedOpenPositionInstruction,
	ParsedPauseMarketInstruction,
	ParsedResetIvInstruction,
	ParsedResetMarketIvInstruction,
	ParsedSettleMultiplePositionsInstruction,
	ParsedSettlePositionInstruction,
	ParsedTransferMarketOperatorInstruction,
	ParsedTransferOwnershipInstruction,
	ParsedUpdateMarketConfigInstruction,
	ParsedWithdrawPoolInstruction,
	ParsedWithdrawVaultInstruction
} from "../instructions"

export const BO_SC_PROGRAM_ADDRESS =
	"HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9" as Address<"HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9">

export enum BoScAccount {
	MarketAccount,
	MasterAccount,
	PoolAccount,
	PositionAccount,
	VaultAccount
}

export function identifyBoScAccount(
	account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BoScAccount {
	const data = "data" in account ? account.data : account
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([201, 78, 187, 225, 240, 198, 201, 251])
			),
			0
		)
	) {
		return BoScAccount.MarketAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([30, 179, 10, 149, 99, 235, 125, 34])
			),
			0
		)
	) {
		return BoScAccount.MasterAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([116, 210, 187, 119, 196, 196, 52, 137])
			),
			0
		)
	) {
		return BoScAccount.PoolAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([60, 125, 250, 193, 181, 109, 238, 86])
			),
			0
		)
	) {
		return BoScAccount.PositionAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([230, 251, 241, 83, 139, 202, 93, 28])
			),
			0
		)
	) {
		return BoScAccount.VaultAccount
	}
	throw new Error("The provided account could not be identified as a boSc account.")
}

export enum BoScInstruction {
	AcceptOwnership,
	FundPool,
	Initialize,
	InitializeMarket,
	InitializePool,
	InitializeVault,
	OpenPosition,
	PauseMarket,
	ResetIv,
	ResetMarketIv,
	SettleMultiplePositions,
	SettlePosition,
	TransferMarketOperator,
	TransferOwnership,
	UpdateMarketConfig,
	WithdrawPool,
	WithdrawVault
}

export function identifyBoScInstruction(
	instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BoScInstruction {
	const data = "data" in instruction ? instruction.data : instruction
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([172, 23, 43, 13, 238, 213, 85, 150])
			),
			0
		)
	) {
		return BoScInstruction.AcceptOwnership
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([36, 57, 233, 176, 181, 20, 87, 159])
			),
			0
		)
	) {
		return BoScInstruction.FundPool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
			),
			0
		)
	) {
		return BoScInstruction.Initialize
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([35, 35, 189, 193, 155, 48, 170, 203])
			),
			0
		)
	) {
		return BoScInstruction.InitializeMarket
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
			),
			0
		)
	) {
		return BoScInstruction.InitializePool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([48, 191, 163, 44, 71, 129, 63, 164])
			),
			0
		)
	) {
		return BoScInstruction.InitializeVault
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
			),
			0
		)
	) {
		return BoScInstruction.OpenPosition
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([216, 238, 4, 164, 65, 11, 162, 91])
			),
			0
		)
	) {
		return BoScInstruction.PauseMarket
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([3, 183, 10, 208, 52, 72, 61, 53])
			),
			0
		)
	) {
		return BoScInstruction.ResetIv
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([119, 251, 177, 189, 166, 234, 89, 86])
			),
			0
		)
	) {
		return BoScInstruction.ResetMarketIv
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([225, 3, 116, 19, 38, 154, 191, 245])
			),
			0
		)
	) {
		return BoScInstruction.SettleMultiplePositions
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([33, 156, 74, 218, 215, 42, 112, 175])
			),
			0
		)
	) {
		return BoScInstruction.SettlePosition
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([205, 70, 53, 252, 53, 239, 214, 31])
			),
			0
		)
	) {
		return BoScInstruction.TransferMarketOperator
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([65, 177, 215, 73, 53, 45, 99, 47])
			),
			0
		)
	) {
		return BoScInstruction.TransferOwnership
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([91, 87, 149, 101, 110, 116, 16, 120])
			),
			0
		)
	) {
		return BoScInstruction.UpdateMarketConfig
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([190, 43, 148, 248, 68, 5, 215, 136])
			),
			0
		)
	) {
		return BoScInstruction.WithdrawPool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([135, 7, 237, 120, 149, 94, 95, 7])
			),
			0
		)
	) {
		return BoScInstruction.WithdrawVault
	}
	throw new Error("The provided instruction could not be identified as a boSc instruction.")
}

export type ParsedBoScInstruction<
	TProgram extends string = "HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9"
> =
	| ({
			instructionType: BoScInstruction.AcceptOwnership
	  } & ParsedAcceptOwnershipInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.FundPool
	  } & ParsedFundPoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.Initialize
	  } & ParsedInitializeInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializeMarket
	  } & ParsedInitializeMarketInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializePool
	  } & ParsedInitializePoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializeVault
	  } & ParsedInitializeVaultInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.OpenPosition
	  } & ParsedOpenPositionInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.PauseMarket
	  } & ParsedPauseMarketInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.ResetIv
	  } & ParsedResetIvInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.ResetMarketIv
	  } & ParsedResetMarketIvInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.SettleMultiplePositions
	  } & ParsedSettleMultiplePositionsInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.SettlePosition
	  } & ParsedSettlePositionInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.TransferMarketOperator
	  } & ParsedTransferMarketOperatorInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.TransferOwnership
	  } & ParsedTransferOwnershipInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.UpdateMarketConfig
	  } & ParsedUpdateMarketConfigInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.WithdrawPool
	  } & ParsedWithdrawPoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.WithdrawVault
	  } & ParsedWithdrawVaultInstruction<TProgram>)
