/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	type EncodedAccount,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getBooleanDecoder,
	getBooleanEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getF64Decoder,
	getF64Encoder,
	getI32Decoder,
	getI32Encoder,
	getI64Decoder,
	getI64Encoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	getU16Decoder,
	getU16Encoder,
	getU32Decoder,
	getU32Encoder,
	getU64Decoder,
	getU64Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array,
	transformEncoder
} from "@solana/kit"

export const MARKET_ACCOUNT_DISCRIMINATOR = new Uint8Array([201, 78, 187, 225, 240, 198, 201, 251])

export function getMarketAccountDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(MARKET_ACCOUNT_DISCRIMINATOR)
}

export type MarketAccount = {
	discriminator: ReadonlyUint8Array
	operator: Address
	backAuthority: Address
	bump: number
	minSettleDelayEpochsSecs: number
	maxSettleDelayEpochsSecs: number
	feeBps: number
	minStake: bigint
	maxStake: bigint
	minPremiumBps: number
	callLambda: number
	putLambda: number
	vegaBuffer: number
	feedId: ReadonlyUint8Array
	stalenessMaxSec: number
	priceExponent: number
	lastPrice: number
	lastTs: bigint
	sigma2: number
	minSigma2: number
	maxSigma2: number
	halfLifeSecs: bigint
	vault: Address
	pool: Address
	treasury: Address
	paused: boolean
}

export type MarketAccountArgs = {
	operator: Address
	backAuthority: Address
	bump: number
	minSettleDelayEpochsSecs: number
	maxSettleDelayEpochsSecs: number
	feeBps: number
	minStake: number | bigint
	maxStake: number | bigint
	minPremiumBps: number
	callLambda: number
	putLambda: number
	vegaBuffer: number
	feedId: ReadonlyUint8Array
	stalenessMaxSec: number
	priceExponent: number
	lastPrice: number
	lastTs: number | bigint
	sigma2: number
	minSigma2: number
	maxSigma2: number
	halfLifeSecs: number | bigint
	vault: Address
	pool: Address
	treasury: Address
	paused: boolean
}

/** Gets the encoder for {@link MarketAccountArgs} account data. */
export function getMarketAccountEncoder(): FixedSizeEncoder<MarketAccountArgs> {
	return transformEncoder(
		getStructEncoder([
			["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
			["operator", getAddressEncoder()],
			["backAuthority", getAddressEncoder()],
			["bump", getU8Encoder()],
			["minSettleDelayEpochsSecs", getU32Encoder()],
			["maxSettleDelayEpochsSecs", getU32Encoder()],
			["feeBps", getU16Encoder()],
			["minStake", getU64Encoder()],
			["maxStake", getU64Encoder()],
			["minPremiumBps", getU16Encoder()],
			["callLambda", getF64Encoder()],
			["putLambda", getF64Encoder()],
			["vegaBuffer", getF64Encoder()],
			["feedId", fixEncoderSize(getBytesEncoder(), 32)],
			["stalenessMaxSec", getU32Encoder()],
			["priceExponent", getI32Encoder()],
			["lastPrice", getF64Encoder()],
			["lastTs", getI64Encoder()],
			["sigma2", getF64Encoder()],
			["minSigma2", getF64Encoder()],
			["maxSigma2", getF64Encoder()],
			["halfLifeSecs", getU64Encoder()],
			["vault", getAddressEncoder()],
			["pool", getAddressEncoder()],
			["treasury", getAddressEncoder()],
			["paused", getBooleanEncoder()]
		]),
		value => ({ ...value, discriminator: MARKET_ACCOUNT_DISCRIMINATOR })
	)
}

/** Gets the decoder for {@link MarketAccount} account data. */
export function getMarketAccountDecoder(): FixedSizeDecoder<MarketAccount> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
		["operator", getAddressDecoder()],
		["backAuthority", getAddressDecoder()],
		["bump", getU8Decoder()],
		["minSettleDelayEpochsSecs", getU32Decoder()],
		["maxSettleDelayEpochsSecs", getU32Decoder()],
		["feeBps", getU16Decoder()],
		["minStake", getU64Decoder()],
		["maxStake", getU64Decoder()],
		["minPremiumBps", getU16Decoder()],
		["callLambda", getF64Decoder()],
		["putLambda", getF64Decoder()],
		["vegaBuffer", getF64Decoder()],
		["feedId", fixDecoderSize(getBytesDecoder(), 32)],
		["stalenessMaxSec", getU32Decoder()],
		["priceExponent", getI32Decoder()],
		["lastPrice", getF64Decoder()],
		["lastTs", getI64Decoder()],
		["sigma2", getF64Decoder()],
		["minSigma2", getF64Decoder()],
		["maxSigma2", getF64Decoder()],
		["halfLifeSecs", getU64Decoder()],
		["vault", getAddressDecoder()],
		["pool", getAddressDecoder()],
		["treasury", getAddressDecoder()],
		["paused", getBooleanDecoder()]
	])
}

/** Gets the codec for {@link MarketAccount} account data. */
export function getMarketAccountCodec(): FixedSizeCodec<MarketAccountArgs, MarketAccount> {
	return combineCodec(getMarketAccountEncoder(), getMarketAccountDecoder())
}

export function decodeMarketAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<MarketAccount, TAddress>
export function decodeMarketAccount<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<MarketAccount, TAddress>
export function decodeMarketAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<MarketAccount, TAddress> | MaybeAccount<MarketAccount, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getMarketAccountDecoder())
}

export async function fetchMarketAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<MarketAccount, TAddress>> {
	const maybeAccount = await fetchMaybeMarketAccount(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeMarketAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<MarketAccount, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeMarketAccount(maybeAccount)
}

export async function fetchAllMarketAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<MarketAccount>[]> {
	const maybeAccounts = await fetchAllMaybeMarketAccount(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeMarketAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<MarketAccount>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeMarketAccount(maybeAccount))
}

export function getMarketAccountSize(): number {
	return 310
}
