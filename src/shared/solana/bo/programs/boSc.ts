/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Address,
	assertIsInstructionWithAccounts,
	containsBytes,
	fixEncoderSize,
	getBytesEncoder,
	type Instruction,
	type InstructionWithData,
	type ReadonlyUint8Array
} from "@solana/kit"
import {
	type ParsedAcceptOwnershipInstruction,
	type ParsedFundPoolInstruction,
	type ParsedInitializeInstruction,
	type ParsedInitializeMarketInstruction,
	type ParsedInitializePoolInstruction,
	type ParsedInitializeVaultInstruction,
	type ParsedOpenPositionInstruction,
	type ParsedPauseMarketInstruction,
	type ParsedResetIvInstruction,
	type ParsedResetMarketIvInstruction,
	type ParsedSettleMultiplePositionsInstruction,
	type ParsedSettlePositionInstruction,
	type ParsedTransferMarketOperatorInstruction,
	type ParsedTransferOwnershipInstruction,
	type ParsedUpdateMarketConfigInstruction,
	type ParsedWithdrawPoolInstruction,
	type ParsedWithdrawVaultInstruction,
	parseAcceptOwnershipInstruction,
	parseFundPoolInstruction,
	parseInitializeInstruction,
	parseInitializeMarketInstruction,
	parseInitializePoolInstruction,
	parseInitializeVaultInstruction,
	parseOpenPositionInstruction,
	parsePauseMarketInstruction,
	parseResetIvInstruction,
	parseResetMarketIvInstruction,
	parseSettleMultiplePositionsInstruction,
	parseSettlePositionInstruction,
	parseTransferMarketOperatorInstruction,
	parseTransferOwnershipInstruction,
	parseUpdateMarketConfigInstruction,
	parseWithdrawPoolInstruction,
	parseWithdrawVaultInstruction
} from "../instructions"

export const BO_SC_PROGRAM_ADDRESS =
	"HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9" as Address<"HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9">

export enum BoScAccount {
	MarketAccount,
	MasterAccount,
	PoolAccount,
	PositionAccount,
	VaultAccount
}

export function identifyBoScAccount(
	account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BoScAccount {
	const data = "data" in account ? account.data : account
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([201, 78, 187, 225, 240, 198, 201, 251])
			),
			0
		)
	) {
		return BoScAccount.MarketAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([30, 179, 10, 149, 99, 235, 125, 34])
			),
			0
		)
	) {
		return BoScAccount.MasterAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([116, 210, 187, 119, 196, 196, 52, 137])
			),
			0
		)
	) {
		return BoScAccount.PoolAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([60, 125, 250, 193, 181, 109, 238, 86])
			),
			0
		)
	) {
		return BoScAccount.PositionAccount
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([230, 251, 241, 83, 139, 202, 93, 28])
			),
			0
		)
	) {
		return BoScAccount.VaultAccount
	}
	throw new Error("The provided account could not be identified as a boSc account.")
}

export enum BoScInstruction {
	AcceptOwnership,
	FundPool,
	Initialize,
	InitializeMarket,
	InitializePool,
	InitializeVault,
	OpenPosition,
	PauseMarket,
	ResetIv,
	ResetMarketIv,
	SettleMultiplePositions,
	SettlePosition,
	TransferMarketOperator,
	TransferOwnership,
	UpdateMarketConfig,
	WithdrawPool,
	WithdrawVault
}

export function identifyBoScInstruction(
	instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BoScInstruction {
	const data = "data" in instruction ? instruction.data : instruction
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([172, 23, 43, 13, 238, 213, 85, 150])
			),
			0
		)
	) {
		return BoScInstruction.AcceptOwnership
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([36, 57, 233, 176, 181, 20, 87, 159])
			),
			0
		)
	) {
		return BoScInstruction.FundPool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
			),
			0
		)
	) {
		return BoScInstruction.Initialize
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([35, 35, 189, 193, 155, 48, 170, 203])
			),
			0
		)
	) {
		return BoScInstruction.InitializeMarket
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
			),
			0
		)
	) {
		return BoScInstruction.InitializePool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([48, 191, 163, 44, 71, 129, 63, 164])
			),
			0
		)
	) {
		return BoScInstruction.InitializeVault
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
			),
			0
		)
	) {
		return BoScInstruction.OpenPosition
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([216, 238, 4, 164, 65, 11, 162, 91])
			),
			0
		)
	) {
		return BoScInstruction.PauseMarket
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([3, 183, 10, 208, 52, 72, 61, 53])
			),
			0
		)
	) {
		return BoScInstruction.ResetIv
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([119, 251, 177, 189, 166, 234, 89, 86])
			),
			0
		)
	) {
		return BoScInstruction.ResetMarketIv
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([225, 3, 116, 19, 38, 154, 191, 245])
			),
			0
		)
	) {
		return BoScInstruction.SettleMultiplePositions
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([33, 156, 74, 218, 215, 42, 112, 175])
			),
			0
		)
	) {
		return BoScInstruction.SettlePosition
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([205, 70, 53, 252, 53, 239, 214, 31])
			),
			0
		)
	) {
		return BoScInstruction.TransferMarketOperator
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([65, 177, 215, 73, 53, 45, 99, 47])
			),
			0
		)
	) {
		return BoScInstruction.TransferOwnership
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([91, 87, 149, 101, 110, 116, 16, 120])
			),
			0
		)
	) {
		return BoScInstruction.UpdateMarketConfig
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([190, 43, 148, 248, 68, 5, 215, 136])
			),
			0
		)
	) {
		return BoScInstruction.WithdrawPool
	}
	if (
		containsBytes(
			data,
			fixEncoderSize(getBytesEncoder(), 8).encode(
				new Uint8Array([135, 7, 237, 120, 149, 94, 95, 7])
			),
			0
		)
	) {
		return BoScInstruction.WithdrawVault
	}
	throw new Error("The provided instruction could not be identified as a boSc instruction.")
}

export type ParsedBoScInstruction<
	TProgram extends string = "HF1uuMHBmtaCYqhFx2wCFYhkAim8uLaxpMUeWmeTXtD9"
> =
	| ({
			instructionType: BoScInstruction.AcceptOwnership
	  } & ParsedAcceptOwnershipInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.FundPool
	  } & ParsedFundPoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.Initialize
	  } & ParsedInitializeInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializeMarket
	  } & ParsedInitializeMarketInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializePool
	  } & ParsedInitializePoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.InitializeVault
	  } & ParsedInitializeVaultInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.OpenPosition
	  } & ParsedOpenPositionInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.PauseMarket
	  } & ParsedPauseMarketInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.ResetIv
	  } & ParsedResetIvInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.ResetMarketIv
	  } & ParsedResetMarketIvInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.SettleMultiplePositions
	  } & ParsedSettleMultiplePositionsInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.SettlePosition
	  } & ParsedSettlePositionInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.TransferMarketOperator
	  } & ParsedTransferMarketOperatorInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.TransferOwnership
	  } & ParsedTransferOwnershipInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.UpdateMarketConfig
	  } & ParsedUpdateMarketConfigInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.WithdrawPool
	  } & ParsedWithdrawPoolInstruction<TProgram>)
	| ({
			instructionType: BoScInstruction.WithdrawVault
	  } & ParsedWithdrawVaultInstruction<TProgram>)

export function parseBoScInstruction<TProgram extends string>(
	instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>
): ParsedBoScInstruction<TProgram> {
	const instructionType = identifyBoScInstruction(instruction)
	switch (instructionType) {
		case BoScInstruction.AcceptOwnership: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.AcceptOwnership,
				...parseAcceptOwnershipInstruction(instruction)
			}
		}
		case BoScInstruction.FundPool: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.FundPool,
				...parseFundPoolInstruction(instruction)
			}
		}
		case BoScInstruction.Initialize: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.Initialize,
				...parseInitializeInstruction(instruction)
			}
		}
		case BoScInstruction.InitializeMarket: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.InitializeMarket,
				...parseInitializeMarketInstruction(instruction)
			}
		}
		case BoScInstruction.InitializePool: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.InitializePool,
				...parseInitializePoolInstruction(instruction)
			}
		}
		case BoScInstruction.InitializeVault: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.InitializeVault,
				...parseInitializeVaultInstruction(instruction)
			}
		}
		case BoScInstruction.OpenPosition: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.OpenPosition,
				...parseOpenPositionInstruction(instruction)
			}
		}
		case BoScInstruction.PauseMarket: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.PauseMarket,
				...parsePauseMarketInstruction(instruction)
			}
		}
		case BoScInstruction.ResetIv: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.ResetIv,
				...parseResetIvInstruction(instruction)
			}
		}
		case BoScInstruction.ResetMarketIv: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.ResetMarketIv,
				...parseResetMarketIvInstruction(instruction)
			}
		}
		case BoScInstruction.SettleMultiplePositions: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.SettleMultiplePositions,
				...parseSettleMultiplePositionsInstruction(instruction)
			}
		}
		case BoScInstruction.SettlePosition: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.SettlePosition,
				...parseSettlePositionInstruction(instruction)
			}
		}
		case BoScInstruction.TransferMarketOperator: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.TransferMarketOperator,
				...parseTransferMarketOperatorInstruction(instruction)
			}
		}
		case BoScInstruction.TransferOwnership: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.TransferOwnership,
				...parseTransferOwnershipInstruction(instruction)
			}
		}
		case BoScInstruction.UpdateMarketConfig: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.UpdateMarketConfig,
				...parseUpdateMarketConfigInstruction(instruction)
			}
		}
		case BoScInstruction.WithdrawPool: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.WithdrawPool,
				...parseWithdrawPoolInstruction(instruction)
			}
		}
		case BoScInstruction.WithdrawVault: {
			assertIsInstructionWithAccounts(instruction)
			return {
				instructionType: BoScInstruction.WithdrawVault,
				...parseWithdrawVaultInstruction(instruction)
			}
		}
		default:
			throw new Error(`Unrecognized instruction type: ${instructionType as string}`)
	}
}
