/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	type Codec,
	combineCodec,
	type Decoder,
	decodeAccount,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getF64Decoder,
	getF64Encoder,
	getI64Decoder,
	getI64Encoder,
	getOptionDecoder,
	getOptionEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	getU64Decoder,
	getU64Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type Option,
	type OptionOrNullable,
	type ReadonlyUint8Array,
	transformEncoder
} from "@solana/kit"
import {
	getPositionModeDecoder,
	getPositionModeEncoder,
	getPositionResultDecoder,
	getPositionResultEncoder,
	getSideDecoder,
	getSideEncoder,
	type PositionMode,
	type PositionModeArgs,
	type PositionResult,
	type PositionResultArgs,
	type Side,
	type SideArgs
} from "../types"

export const POSITION_ACCOUNT_DISCRIMINATOR = new Uint8Array([60, 125, 250, 193, 181, 109, 238, 86])

export function getPositionAccountDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_ACCOUNT_DISCRIMINATOR)
}

export type PositionAccount = {
	discriminator: ReadonlyUint8Array
	id: Address
	user: Address
	feeProvider: Address
	side: Side
	amount: bigint
	premium: number
	premiumAmount: bigint
	spotPrice: number
	boundaryPrice: number
	multiplier: number
	finalPrice: Option<number>
	startTime: bigint
	endTime: bigint
	settledTime: Option<bigint>
	result: Option<PositionResult>
	bump: number
	mode: PositionMode
}

export type PositionAccountArgs = {
	id: Address
	user: Address
	feeProvider: Address
	side: SideArgs
	amount: number | bigint
	premium: number
	premiumAmount: number | bigint
	spotPrice: number
	boundaryPrice: number
	multiplier: number
	finalPrice: OptionOrNullable<number>
	startTime: number | bigint
	endTime: number | bigint
	settledTime: OptionOrNullable<number | bigint>
	result: OptionOrNullable<PositionResultArgs>
	bump: number
	mode: PositionModeArgs
}

/** Gets the encoder for {@link PositionAccountArgs} account data. */
export function getPositionAccountEncoder(): Encoder<PositionAccountArgs> {
	return transformEncoder(
		getStructEncoder([
			["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
			["id", getAddressEncoder()],
			["user", getAddressEncoder()],
			["feeProvider", getAddressEncoder()],
			["side", getSideEncoder()],
			["amount", getU64Encoder()],
			["premium", getF64Encoder()],
			["premiumAmount", getU64Encoder()],
			["spotPrice", getF64Encoder()],
			["boundaryPrice", getF64Encoder()],
			["multiplier", getF64Encoder()],
			["finalPrice", getOptionEncoder(getF64Encoder())],
			["startTime", getI64Encoder()],
			["endTime", getI64Encoder()],
			["settledTime", getOptionEncoder(getI64Encoder())],
			["result", getOptionEncoder(getPositionResultEncoder())],
			["bump", getU8Encoder()],
			["mode", getPositionModeEncoder()]
		]),
		value => ({ ...value, discriminator: POSITION_ACCOUNT_DISCRIMINATOR })
	)
}

/** Gets the decoder for {@link PositionAccount} account data. */
export function getPositionAccountDecoder(): Decoder<PositionAccount> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
		["id", getAddressDecoder()],
		["user", getAddressDecoder()],
		["feeProvider", getAddressDecoder()],
		["side", getSideDecoder()],
		["amount", getU64Decoder()],
		["premium", getF64Decoder()],
		["premiumAmount", getU64Decoder()],
		["spotPrice", getF64Decoder()],
		["boundaryPrice", getF64Decoder()],
		["multiplier", getF64Decoder()],
		["finalPrice", getOptionDecoder(getF64Decoder())],
		["startTime", getI64Decoder()],
		["endTime", getI64Decoder()],
		["settledTime", getOptionDecoder(getI64Decoder())],
		["result", getOptionDecoder(getPositionResultDecoder())],
		["bump", getU8Decoder()],
		["mode", getPositionModeDecoder()]
	])
}

/** Gets the codec for {@link PositionAccount} account data. */
export function getPositionAccountCodec(): Codec<PositionAccountArgs, PositionAccount> {
	return combineCodec(getPositionAccountEncoder(), getPositionAccountDecoder())
}

export function decodePositionAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<PositionAccount, TAddress>
export function decodePositionAccount<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<PositionAccount, TAddress>
export function decodePositionAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<PositionAccount, TAddress> | MaybeAccount<PositionAccount, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getPositionAccountDecoder())
}

export async function fetchPositionAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<PositionAccount, TAddress>> {
	const maybeAccount = await fetchMaybePositionAccount(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybePositionAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<PositionAccount, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodePositionAccount(maybeAccount)
}

export async function fetchAllPositionAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<PositionAccount>[]> {
	const maybeAccounts = await fetchAllMaybePositionAccount(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybePositionAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<PositionAccount>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodePositionAccount(maybeAccount))
}
