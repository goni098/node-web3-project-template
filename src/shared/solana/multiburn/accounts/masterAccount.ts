/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	type Codec,
	combineCodec,
	type Decoder,
	decodeAccount,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getAddressDecoder,
	getAddressEncoder,
	getBytesDecoder,
	getBytesEncoder,
	getOptionDecoder,
	getOptionEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type Option,
	type OptionOrNullable,
	type ReadonlyUint8Array,
	transformEncoder
} from "@solana/kit"

export const MASTER_ACCOUNT_DISCRIMINATOR = new Uint8Array([30, 179, 10, 149, 99, 235, 125, 34])

export function getMasterAccountDiscriminatorBytes() {
	return fixEncoderSize(getBytesEncoder(), 8).encode(MASTER_ACCOUNT_DISCRIMINATOR)
}

export type MasterAccount = {
	discriminator: ReadonlyUint8Array
	master: Address
	pendingMaster: Option<Address>
	bump: number
}

export type MasterAccountArgs = {
	master: Address
	pendingMaster: OptionOrNullable<Address>
	bump: number
}

/** Gets the encoder for {@link MasterAccountArgs} account data. */
export function getMasterAccountEncoder(): Encoder<MasterAccountArgs> {
	return transformEncoder(
		getStructEncoder([
			["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
			["master", getAddressEncoder()],
			["pendingMaster", getOptionEncoder(getAddressEncoder())],
			["bump", getU8Encoder()]
		]),
		value => ({ ...value, discriminator: MASTER_ACCOUNT_DISCRIMINATOR })
	)
}

/** Gets the decoder for {@link MasterAccount} account data. */
export function getMasterAccountDecoder(): Decoder<MasterAccount> {
	return getStructDecoder([
		["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
		["master", getAddressDecoder()],
		["pendingMaster", getOptionDecoder(getAddressDecoder())],
		["bump", getU8Decoder()]
	])
}

/** Gets the codec for {@link MasterAccount} account data. */
export function getMasterAccountCodec(): Codec<MasterAccountArgs, MasterAccount> {
	return combineCodec(getMasterAccountEncoder(), getMasterAccountDecoder())
}

export function decodeMasterAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<MasterAccount, TAddress>
export function decodeMasterAccount<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<MasterAccount, TAddress>
export function decodeMasterAccount<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<MasterAccount, TAddress> | MaybeAccount<MasterAccount, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getMasterAccountDecoder())
}

export async function fetchMasterAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<MasterAccount, TAddress>> {
	const maybeAccount = await fetchMaybeMasterAccount(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeMasterAccount<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<MasterAccount, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeMasterAccount(maybeAccount)
}

export async function fetchAllMasterAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<MasterAccount>[]> {
	const maybeAccounts = await fetchAllMaybeMasterAccount(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeMasterAccount(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<MasterAccount>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeMasterAccount(maybeAccount))
}
